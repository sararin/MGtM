operations -> computer calculations
              arithmetic operations -> add/sub etc
              logic operations -> and/or/not

components of modern computer -> control unit -> reads instructions from memory and interprets them
                                 arithmetic unit -> actually does stuff
                                 input dev -> like keyboard
                                 output dev -> like monitor
                                 memory sys

ALU -> takes two inputs, command input, returns output and status output
       A,B -> inputs
       + -> command input
       A+B -> output
       1 -> status output(in this case indicating sucess)

Information -> everything that you can percieve
               noise -> unimportant information
               signal -> important
               you want to maximalise signal-to-noise ratio
               info on pc is discreete, irl information is often continuous
               so since digital is discrete, you lose some of the info

Why discrete -> cause there are only two states
                low voltage and high voltage
                high volt -> close to supply voltage
                low volt -> close to the ground(zero)

Counting in binary -> remember bit is one digit
                      by shifting you multiply or divide by two
                      you also have to remember about carry-over values which happen when you try to make number bigger than 1
                      for example 1 + 1 = 10(the carry happens)
                      The substraction though is different
                      Two's compliment -> instead of A-B you perform ( (not A) + 1 ) + B
                      Fixed point -> dec point stays in place
                      Floating point -> it's shifted with information how much(the *10^x bit)
                                        in PC we use base 2 so for example 1.69 * 2^n

Logic operators -> in integrated circuts
                   generally logic circut takes some input and spits output
                   AND -> =) takes A B and returns true if A AND B are true
                   OR -> => takes A B and returns true if A OR B are true
                   NOT -> >. takes A and returns the oposite
                   NAND -> =). takes A B and returns true if A AND B arent true
                   NOR -> =>. takes A B and returns true if A OR B arent true
                   XOR -> |=> takes A B and returns true if either A OR B are true
                   De Morgans theorem -> NAND is the same as using OR on each inputs complement
                                         NOR is the same as using AND and each inputs complement
                                         NAND -> =). same as ..=> as in negating the inputs and ORing
                                         NOR -> =>. same as ..=) same as negating the inputs and ANDing

Half adder! -> uses AND =) and XOR |=> gates
               XOR is used for lower digit
               while AND decides whenever or not set carry to 1
               A XOR B = value of A+B
               A AND B = if carry exist(for 1 AND 1 it does)
               Full adder -> (A B)half-adder(S1 Cout1) 
                             (S1 Cin)half-adder(S2 Cout2)
                             (Cout1 Cout2)OR(Cout3)
                             final is (S2 Cout3)
               Ripple carry adder -> 1 half-adder and n full-adders
                                     (A0 B0)Half-adder(S0 Cout0)
                                     (A1 B1 Cout0)Full-adder(S1 Cout1)
                                     ...
                                     (An Bn Cout(n-1))Full-adder(Sn Coutn)
                                     (Sn Cout)                                     
                                     they are slow as fuck because of the carry tho
               Carry look-ahead adder -> determines the direction during add or sub
                                         circuit is bigger but a lot quicker

Registers -> memory storage inside of CPU(very short term)
             used to perform calculations before they are stored elsewere
Memory -> important, you can't store everything in registers after all
          so you have dedicated circuts which store that(latch),
          they have to have some trigger condition to swap 1 and 0
          flip-flop -> basic component of memory circuit
                       they can freeily change states based on input
                       accepts two inputs(most of the time) and two ouputs Q and ~Q
                       RS flip-flop -> R(eset) S(et)
                                       set S to 1 makes Q 1
                                       set R to 1 and no matter the state of S, Q will be 0
                                       it remembers which it got last S or R and sets Q accordingly
                                       (S, output of 2st NAND)(NAND)(Q)
                                       (R, output of 1st NAND)(NAND)(~Q)
                                       you can replace NAND with NOR
                                       (S, R) -> (Q ~Q)
                                       (1, 1) -> (no change) (0, 1) -> (1, 0 set) (1, 0) -> (0, 1 reset) (0, 0) -> (1, 1 illegal)
                       D flip-flop -> it reads state of input D when input C changes from low state to high state
                                      Clock -> stands for C most of the time
                                               most of them raising edge(0 changing state to 1) is called action signal
                                               if it goes from low to high it's called rising edge
                                               if it goes from high to low it's called falling edge
                       T flip-flop -> when input T does the raising edge thing(changes state from low to high)
                                      output Q changes state
                                      toggling -> what T stands in this flip-flop
                                                  flipping between 1 and 0
                                      counter circuit -> made out of chaining serval T flip-flops together
                                                         second T changes state when first T creates a raising edge
                                                         so it's two times slower, third one is 4 times slower 4th one is 8 times slower
                                                         01 -> 0011 -> 00001111 -> 0000000011111111
                                                         asynchronous counter -> this is example of such counter cause flip-flops aren't connected to one clock
                                                         synchronous counter -> every flip-flop gets trigger signal from one clock, they all turn on the same time

HDL -> hardware description language, defines operations on the circuit
CAD -> computer aided design, we don't draw them by hand but design them in our computers which speed up the process
       it was bootstrapping of sorts, we designed simple programs first

Address -> a memory location
           memory -> place where data and programs are stored
                     good practice, segment data and programs
                     CPU has full control over address space
           why addresses are good thing? CPU can point to address and read data from that point in memory
Bus -> path that transmits data
       actually caled address bus
       CPU -(address bus)-> memory
       CPU <-(data bus)- memory
       CPU -(internal data bus(MUX which change flow of data))-> inside CPU
       CPU -(external bus USB)- memory
       bundled signal pathways -> what buses really are
                                  each signal pathway codes only one bit
                                  so you have to combine many to send bigger amounts of data than 1bit
                                  for example, if buses are 4bit wide
                                  4bit inputs enter ALU and 4bit output exits it
       Address space size -> how large your memory is, determined by address bus width
                             mem capacity and bus width -> if our address bus width is n bits,
                                                           then we have 2^n addresses
                                                           our memory capacity is (2^n)/8 KB
R/W and I/O -> control signals
               R/W -> stands for read/write
                      read -> extract data(load)
                      write -> save data(store)
                      R/W -> hardware perspective, electrical operations on memory
                      L/S -> software perspective, all about registers and it's relation to memory
                      CPU deals with R/W instruction signals, and talks to memory using buses
                      Bus -> address bus gives addres
                             control bus gives instruction
                             data bus fetches the data
               I/O -> stands for input/output
                      I/O control signals!
                      I/O port -> connects input device and CPU directly
Instructions -> instruction resides at some address, and contains operands(which store some address) and opcode(which defines operation)
                opcodes -> short for operation code
                           operates on operands
                           operands -> most often they are some addresses in memory
                so entire thing looks like
                (data at address 30) (opcode) (data at address 31)
                registers -> you can't execute instruction directly
                             you have to use a register to store data first
                             two kinds of registers: accumulator -> used for calculations
                                                     general purpose -> everything else
                so since you need to use registers, in reality addition looks like this
                save data from address X at accumulator
                save data from addrtess Y to general purpose register
                accumulator contains result of addition of those two
                instruction register -> stores instruction for program read from memory

Instruction cycle -> program counter(PC) -> hold address of next instruction to be executed
                                            because of jumps and branches, it doesn't have to count from 1 to n
                     cycle -> after you execute an operation, address of next instruction from PC
                              is transfered to address register and forwarded to memory
                              then, memory sends instruction located at that address back to CPU
                              it's stored in instruction register, decoded and interpreted
                              then results are stored in memory
                     instruction decoder -> breaks down instruction from memory into form CPU can understand

Virtual memory -> OS decides how programs interact with physical memory.
                  it also only exposes it through virtual memory(this is what programs interact with)
                  hardware mapping virtual memoery to physical memory is Memory Management Unit

Memory ->
